<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML5 MIDI Player & Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/midi-parser-js@4.0.4/build/midi-parser.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { background-color: #0c0c0c; display: block; }
        #top-bar { position: absolute; top: 0; left: 0; width: 100%; z-index: 150; }
        #songPositionSlider { width: 100%; margin: 0; display: none; }
        #ui-container { position: absolute; top: 20px; left: 0; padding: 15px; z-index: 100; color: #fff; font-size: 16px; }
        .control-group { display: flex; align-items: center; margin-bottom: 10px; }
        .control-group label { cursor: pointer; margin-right: 10px; min-width: 130px; }
        #midiFileInput { display: none; }
        #uploadLabel { background-color: #337ab7; color: white; padding: 8px 12px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        #uploadLabel:hover { background-color: #286090; }
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white; display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-size: 1.8em; text-align: center; cursor: pointer; z-index: 200;
        }
        #start-overlay p { font-size: 0.6em; margin-top: 10px; opacity: 0.8; }
    </style>
</head>
<body>
    <div id="start-overlay">
        Click to Initialize
        <p>Upload a .MID file to begin</p>
    </div>
    <div id="top-bar">
        <input type="range" id="songPositionSlider" min="0" max="100" value="0" step="0.01">
    </div>
    <div id="ui-container">
        <div class="control-group">
            <label id="uploadLabel" for="midiFileInput">Upload MIDI File</label>
            <input type="file" id="midiFileInput" accept=".mid,.midi">
        </div>
        <div class="control-group">
            <label for="showLabelsCheckbox">Show Note Labels (C, D#)</label>
            <input type="checkbox" id="showLabelsCheckbox">
        </div>
        <div class="control-group">
            <label for="volumeSlider">Volume</label>
            <input type="range" id="volumeSlider" min="0" max="1" value="0.3" step="0.01">
        </div>
    </div>
    <canvas id="pianoCanvas"></canvas>

<script>
    // --- Element Refs ---
    const canvas = document.getElementById('pianoCanvas');
    const ctx = canvas.getContext('2d');
    const showLabelsCheckbox = document.getElementById('showLabelsCheckbox');
    const volumeSlider = document.getElementById('volumeSlider');
    const startOverlay = document.getElementById('start-overlay');
    const midiFileInput = document.getElementById('midiFileInput');
    const songPositionSlider = document.getElementById('songPositionSlider');

    // --- State ---
    let audioContext, masterGain;
    let visualNotes = []; // Notes for drawing
    let audioNotes = [];  // Notes for playing sound
    let isPlaying = false;
    let startTime = 0;
    let songStartTicker = 0;
    let animationFrameId;

    // --- Visual Config ---
    const NOTE_FALL_DURATION = 2.0; // Time in seconds for a note to fall from top to key

    // --- Audio Functions ---
    function setupAudio() {
        if (audioContext) return;
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioContext.createGain();
        masterGain.connect(audioContext.destination);
        masterGain.gain.value = volumeSlider.value;
        volumeSlider.addEventListener('input', (e) => {
            if (masterGain) masterGain.gain.value = e.target.value;
        });
    }

    function midiToFreq(midi) { return 440 * Math.pow(2, (midi - 69) / 12); }

    function playNoteSound(midi, time) {
        if (!audioContext) return;
        const osc = audioContext.createOscillator();
        const noteGain = audioContext.createGain();
        osc.connect(noteGain);
        noteGain.connect(masterGain);
        osc.type = 'triangle';
        osc.frequency.value = midiToFreq(midi);
        noteGain.gain.setValueAtTime(masterGain.gain.value, time);
        noteGain.gain.exponentialRampToValueAtTime(0.0001, time + 0.8);
        osc.start(time);
        osc.stop(time + 0.8);
    }

    // --- MIDI Processing ---
    midiFileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            const parsedMidi = MidiParser.parse(e.target.result);
            processMidiData(parsedMidi);
            startPlayback();
        };
        reader.readAsArrayBuffer(file);
    });

    function processMidiData(parsedMidi) {
        visualNotes = [];
        let ticksPerQuarterNote = parsedMidi.timeDivision;
        let microsecondsPerQuarterNote = 500000; // Default 120 bpm
        let absoluteTick = 0;

        parsedMidi.track.forEach(track => {
            const noteOnEvents = {};
            absoluteTick = 0;
            track.event.forEach(event => {
                absoluteTick += event.deltaTime;
                const absoluteTimeSeconds = (absoluteTick / ticksPerQuarterNote) * (microsecondsPerQuarterNote / 1000000);

                if (event.metaType === 81) { // Set Tempo
                    microsecondsPerQuarterNote = event.data;
                } else if (event.type === 9) { // Note On
                    noteOnEvents[event.data[0]] = { time: absoluteTimeSeconds, velocity: event.data[1] };
                } else if (event.type === 8 || (event.type === 9 && event.data[1] === 0)) { // Note Off
                    const onEvent = noteOnEvents[event.data[0]];
                    if (onEvent) {
                        visualNotes.push({
                            midi: event.data[0],
                            time: onEvent.time,
                            duration: absoluteTimeSeconds - onEvent.time,
                            velocity: onEvent.velocity
                        });
                        delete noteOnEvents[event.data[0]];
                    }
                }
            });
        });

        visualNotes.sort((a, b) => a.time - b.time);
        audioNotes = JSON.parse(JSON.stringify(visualNotes)); // Deep copy for audio scheduling
        const totalDuration = visualNotes.length > 0 ? visualNotes[visualNotes.length - 1].time : 0;
        songPositionSlider.max = totalDuration;
        songPositionSlider.style.display = 'block';
    }
    
    // --- Playback Control ---
    function startPlayback() {
        if (isPlaying) return;
        isPlaying = true;
        startTime = audioContext.currentTime;
        songStartTicker = 0;

        // Schedule all audio notes at once
        audioNotes.forEach(note => playNoteSound(note.midi, startTime + note.time));
        
        animate();
    }

    songPositionSlider.addEventListener('input', (e) => {
        const seekTime = parseFloat(e.target.value);
        if (isPlaying) {
            startTime = audioContext.currentTime - seekTime;
        } else {
            songStartTicker = seekTime;
        }
    });

    // --- Keyboard & Note Drawing ---
    const keyMap = {};
    const whiteKeyCount = 52;
    const whiteKeyWidth = window.innerWidth / whiteKeyCount;
    const whiteKeyHeight = window.innerHeight * 0.25;
    const blackKeyWidth = whiteKeyWidth * 0.7;
    const blackKeyHeight = whiteKeyHeight * 0.6;
    let whiteKeyIndex = 0;
    for (let i = 0; i < 88; i++) {
        const midi = 21 + i;
        const isBlack = [1, 3, 6, 8, 10].includes(i % 12);
        keyMap[midi] = {
            isBlack,
            x: isBlack ? (whiteKeyIndex * whiteKeyWidth) - (blackKeyWidth / 2) : whiteKeyIndex * whiteKeyWidth,
            width: isBlack ? blackKeyWidth : whiteKeyWidth,
        };
        if (!isBlack) whiteKeyIndex++;
    }

    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    function midiToNoteName(midi) { return noteNames[midi % 12]; }

    // --- Main Animation Loop ---
    function animate() {
        if (!isPlaying) return;
        
        const currentTime = audioContext.currentTime - startTime;
        songPositionSlider.value = currentTime;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const keyboardTopY = canvas.height - whiteKeyHeight;
        
        // 1. Draw Falling Notes
        visualNotes.forEach(note => {
            const timeUntilHit = note.time - currentTime;
            if (timeUntilHit > 0 && timeUntilHit < NOTE_FALL_DURATION) {
                const key = keyMap[note.midi];
                const noteWidth = key.isBlack ? blackKeyWidth * 0.9 : whiteKeyWidth * 0.9;
                const xPos = key.x + (key.width - noteWidth) / 2;
                const yPos = keyboardTopY - (timeUntilHit / NOTE_FALL_DURATION) * keyboardTopY;
                const noteHeight = (note.duration / NOTE_FALL_DURATION) * keyboardTopY;

                ctx.fillStyle = key.isBlack ? 'rgba(10, 150, 10, 1)' : 'rgba(50, 255, 50, 1)';
                ctx.beginPath();
                ctx.roundRect(xPos, yPos - noteHeight, noteWidth, noteHeight, 8);
                ctx.fill();

                if (showLabelsCheckbox.checked) {
                    ctx.fillStyle = '#FFF';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(midiToNoteName(note.midi), xPos + noteWidth / 2, yPos - 5);
                }
            }
        });

        // 2. Draw Keyboard and Hit Effects
        whiteKeyIndex = 0;
        for (let i = 0; i < 88; i++) {
            const midi = 21 + i;
            const key = keyMap[midi];
            const isBlack = [1, 3, 6, 8, 10].includes(i % 12);
            
            // Draw hit effect
            const timeSinceHit = currentTime - audioNotes.find(n => n.midi === midi && currentTime > n.time)?.time;
            if (timeSinceHit >= 0 && timeSinceHit < 0.5) {
                const alpha = 1.0 - (timeSinceHit / 0.5);
                const highlightColor = isBlack ? `rgba(10, 120, 10, ${alpha})` : `rgba(10, 200, 10, ${alpha})`;
                ctx.fillStyle = highlightColor;
                ctx.fillRect(key.x, keyboardTopY, key.width, isBlack ? blackKeyHeight : whiteKeyHeight);
            }

            // Draw key
            ctx.fillStyle = isBlack ? '#222' : '#FFF';
            ctx.fillRect(key.x, keyboardTopY, key.width, isBlack ? blackKeyHeight : whiteKeyHeight);
            if (!isBlack) {
                ctx.strokeStyle = '#bbb';
                ctx.strokeRect(key.x, keyboardTopY, key.width, whiteKeyHeight);
                whiteKeyIndex++;
            }
        }
        
        if (currentTime > songPositionSlider.max) {
             isPlaying = false;
        }

        animationFrameId = requestAnimationFrame(animate);
    }

    // --- Start Logic ---
    startOverlay.addEventListener('click', () => {
        setupAudio();
        startOverlay.style.display = 'none';
    }, { once: true });
</script>
</body>
</html>