<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML5 MIDI Player & Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/midi-parser-js@4.0.4/build/midi-parser.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { background-color: #0c0c0c; display: block; }
        #top-bar { position: absolute; top: 0; left: 0; width: 100%; z-index: 150; }
        #songPositionSlider { width: 100%; margin: 0; display: none; }
        #ui-container { position: absolute; top: 20px; left: 0; padding: 15px; z-index: 100; color: #fff; font-size: 16px; }
        .control-group { display: flex; align-items: center; margin-bottom: 10px; }
        .control-group label { cursor: pointer; margin-right: 10px; min-width: 130px; }
        #midiFileInput { display: none; }
        #uploadLabel { background-color: #337ab7; color: white; padding: 8px 12px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        #uploadLabel:hover { background-color: #286090; }
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white; display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-size: 1.8em; text-align: center; cursor: pointer; z-index: 200;
        }
        #start-overlay p { font-size: 0.6em; margin-top: 10px; opacity: 0.8; }
    </style>
</head>
<body>
    <div id="start-overlay">
        Click to Start
        <p>"Merry-Go-Round of Life" will play by default if available.</p>
    </div>
    <div id="top-bar">
        <input type="range" id="songPositionSlider" min="0" max="100" value="0" step="0.01">
    </div>
    <div id="ui-container">
        <div class="control-group">
            <label id="uploadLabel" for="midiFileInput">Upload Different MIDI</label>
            <input type="file" id="midiFileInput" accept=".mid,.midi">
        </div>
        <div class="control-group">
            <label for="showLabelsCheckbox">Show Note Labels (C, D#)</label>
            <input type="checkbox" id="showLabelsCheckbox">
        </div>
        <div class="control-group">
            <label for="volumeSlider">Volume</label>
            <input type="range" id="volumeSlider" min="0" max="1" value="0.3" step="0.01">
        </div>
    </div>
    <canvas id="pianoCanvas"></canvas>

<script>
    // --- Element Refs ---
    const canvas = document.getElementById('pianoCanvas');
    const ctx = canvas.getContext('2d');
    const showLabelsCheckbox = document.getElementById('showLabelsCheckbox');
    const volumeSlider = document.getElementById('volumeSlider');
    const startOverlay = document.getElementById('start-overlay');
    const midiFileInput = document.getElementById('midiFileInput');
    const songPositionSlider = document.getElementById('songPositionSlider');

    // --- State ---
    let audioContext, masterGain;
    let visualNotes = [];
    let audioNotes = [];
    let isPlaying = false;
    let startTime = 0;
    let animationFrameId;

    // --- Audio Functions ---
    function setupAudio() {
        if (audioContext) return;
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioContext.createGain();
        masterGain.connect(audioContext.destination);
        masterGain.gain.value = volumeSlider.value;
        volumeSlider.addEventListener('input', (e) => {
            if (masterGain) masterGain.gain.value = e.target.value;
        });
    }

    function midiToFreq(midi) { return 440 * Math.pow(2, (midi - 69) / 12); }

    function playNoteSound(midi, time) {
        if (!audioContext) return;
        const osc = audioContext.createOscillator();
        const noteGain = audioContext.createGain();
        osc.connect(noteGain);
        noteGain.connect(masterGain);
        osc.type = 'triangle';
        osc.frequency.value = midiToFreq(midi);
        const now = audioContext.currentTime;
        const playTime = now + (time - (now - startTime));
        noteGain.gain.setValueAtTime(masterGain.gain.value, playTime);
        noteGain.gain.exponentialRampToValueAtTime(0.0001, playTime + 0.8);
        osc.start(playTime);
        osc.stop(playTime + 0.8);
    }

    // --- MIDI Processing & Loading ---
    function stopCurrentSong() {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        isPlaying = false;
        // This is a simple way to stop sound; a more robust solution would track and stop oscillators.
        if (audioContext) {
             masterGain.gain.setValueAtTime(masterGain.gain.value, audioContext.currentTime);
             masterGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.1);
             // Re-establish volume for next song
             setTimeout(() => masterGain.gain.linearRampToValueAtTime(volumeSlider.value, audioContext.currentTime + 0.1), 200);
        }
    }

    midiFileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            stopCurrentSong();
            const parsedMidi = MidiParser.parse(e.target.result);
            processMidiData(parsedMidi);
            startPlayback();
        };
        reader.readAsDataURL(file);
    });

    async function loadDefaultSong() {
        try {
            const defaultSongName = "Joe Hisaishi - Merry Go Round Of Life (Howl's Moving Castle).mid";
            const response = await fetch(defaultSongName);
            if (!response.ok) {
                console.log("Default MIDI file not found. Waiting for user upload.");
                return;
            }
            const arrayBuffer = await response.arrayBuffer();
            // The parser expects a Data URL, so we construct one.
            let binary = '';
            const bytes = new Uint8Array(arrayBuffer);
            bytes.forEach((byte) => binary += String.fromCharCode(byte));
            const base64 = window.btoa(binary);
            const dataUrl = `data:audio/midi;base64,${base64}`;

            const parsedMidi = MidiParser.parse(dataUrl);
            processMidiData(parsedMidi);
            startPlayback();
        } catch (error) {
            console.error("Error loading default song:", error);
        }
    }
    
    function processMidiData(parsedMidi) {
        visualNotes = [];
        let ticksPerQuarterNote = parsedMidi.timeDivision;
        let microsecondsPerQuarterNote = 500000;
        let absoluteTick = 0;

        parsedMidi.track.forEach(track => {
            const noteOnEvents = {};
            absoluteTick = 0;
            track.event.forEach(event => {
                absoluteTick += event.deltaTime;
                const absoluteTimeSeconds = (absoluteTick / ticksPerQuarterNote) * (microsecondsPerQuarterNote / 1000000);

                if (event.metaType === 81) {
                    microsecondsPerQuarterNote = event.data;
                } else if (event.type === 9 && event.data[1] > 0) {
                    noteOnEvents[event.data[0]] = { time: absoluteTimeSeconds };
                } else if (event.type === 8 || (event.type === 9 && event.data[1] === 0)) {
                    const onEvent = noteOnEvents[event.data[0]];
                    if (onEvent) {
                        visualNotes.push({
                            midi: event.data[0],
                            time: onEvent.time,
                            duration: absoluteTimeSeconds - onEvent.time,
                        });
                        delete noteOnEvents[event.data[0]];
                    }
                }
            });
        });

        visualNotes.sort((a, b) => a.time - b.time);
        audioNotes = JSON.parse(JSON.stringify(visualNotes));
        const totalDuration = visualNotes.length > 0 ? visualNotes[visualNotes.length - 1].time : 0;
        songPositionSlider.max = totalDuration;
        songPositionSlider.style.display = 'block';
    }
    
    // --- Playback Control ---
    function startPlayback(seekTime = 0) {
        if (isPlaying) return;
        isPlaying = true;
        startTime = audioContext.currentTime - seekTime;

        audioNotes.forEach(note => {
            if (note.time >= seekTime) {
                playNoteSound(note.midi, startTime + note.time);
            }
        });
        
        animate();
    }

    songPositionSlider.addEventListener('input', (e) => {
        stopCurrentSong();
        // A short delay to allow sounds to fade before restarting
        setTimeout(() => {
            startPlayback(parseFloat(e.target.value));
        }, 150);
    });

    // --- Main Animation Loop & Drawing ---
    const NOTE_FALL_DURATION = 2.0;
    const keyMap = {};
    const whiteKeyWidth = window.innerWidth / 52;
    const whiteKeyHeight = window.innerHeight * 0.25;
    const blackKeyWidth = whiteKeyWidth * 0.7;
    const blackKeyHeight = whiteKeyHeight * 0.6;
    let whiteKeyIndex = 0;
    for (let i = 0; i < 88; i++) {
        const midi = 21 + i;
        const isBlack = [1, 3, 6, 8, 10].includes(i % 12);
        keyMap[midi] = {
            isBlack,
            x: isBlack ? (whiteKeyIndex * whiteKeyWidth) - (blackKeyWidth / 2) : whiteKeyIndex * whiteKeyWidth,
            width: isBlack ? blackKeyWidth : whiteKeyWidth,
        };
        if (!isBlack) whiteKeyIndex++;
    }

    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    function midiToNoteName(midi) { return noteNames[midi % 12]; }

    function animate() {
        if (!isPlaying) return;
        
        const currentTime = audioContext.currentTime - startTime;
        if (currentTime > songPositionSlider.max) {
             stopCurrentSong();
             return; // End of song
        }
        songPositionSlider.value = currentTime;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const keyboardTopY = canvas.height - whiteKeyHeight;
        
        visualNotes.forEach(note => {
            const timeUntilHit = note.time - currentTime;
            if (timeUntilHit > -note.duration && timeUntilHit < NOTE_FALL_DURATION) {
                const key = keyMap[note.midi];
                const noteWidth = key.isBlack ? blackKeyWidth * 0.9 : whiteKeyWidth * 0.9;
                const xPos = key.x + (key.width - noteWidth) / 2;
                
                const yStart = keyboardTopY - (timeUntilHit / NOTE_FALL_DURATION) * (keyboardTopY);
                const noteHeight = (note.duration / NOTE_FALL_DURATION) * (keyboardTopY);
                
                ctx.fillStyle = key.isBlack ? 'rgba(10, 150, 10, 1)' : 'rgba(50, 255, 50, 1)';
                ctx.beginPath();
                ctx.roundRect(xPos, yStart - noteHeight, noteWidth, noteHeight, 8);
                ctx.fill();

                if (showLabelsCheckbox.checked) {
                    ctx.fillStyle = '#FFF';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(midiToNoteName(note.midi), xPos + noteWidth / 2, yStart - 5);
                }
            }
        });

        for (let i = 0; i < 88; i++) {
            const midi = 21 + i;
            const key = keyMap[midi];
            const timeSinceHit = currentTime - visualNotes.find(n => n.midi === midi && currentTime >= n.time && currentTime < n.time + n.duration)?.time;
            
            ctx.fillStyle = key.isBlack ? '#222' : '#FFF';
            if (timeSinceHit >= 0) {
                 ctx.fillStyle = key.isBlack ? 'rgba(10, 120, 10, 1)' : 'rgba(10, 200, 10, 1)';
            }
            ctx.fillRect(key.x, keyboardTopY, key.width, key.isBlack ? blackKeyHeight : whiteKeyHeight);

            if (!key.isBlack) {
                ctx.strokeStyle = '#bbb';
                ctx.strokeRect(key.x, keyboardTopY, key.width, whiteKeyHeight);
            }
        }
        
        animationFrameId = requestAnimationFrame(animate);
    }

    // --- Start Logic ---
    startOverlay.addEventListener('click', async () => {
        setupAudio();
        startOverlay.style.display = 'none';
        await loadDefaultSong();
    }, { once: true });
</script>
</body>
</html>
