<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML5 MIDI Player & Visualizer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { background-color: #0c0c0c; display: block; }
        #top-bar { position: absolute; top: 0; left: 0; width: 100%; z-index: 150; }
        #songPositionSlider { width: 100%; margin: 0; display: none; }
        #ui-container { position: absolute; top: 20px; left: 0; padding: 15px; z-index: 100; color: #fff; font-size: 16px; }
        .control-group { display: flex; align-items: center; margin-bottom: 10px; }
        .control-group label { cursor: pointer; margin-right: 10px; min-width: 130px; }
        #midiFileInput { display: none; }
        #uploadLabel { background-color: #337ab7; color: white; padding: 8px 12px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        #uploadLabel:hover { background-color: #286090; }
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white; display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-size: 1.8em; text-align: center; cursor: pointer; z-index: 200;
        }
        #start-overlay p { font-size: 0.6em; margin-top: 10px; opacity: 0.8; }
    </style>
</head>
<body>
    <div id="start-overlay">
        Click to Start
        <p>"Merry-Go-Round of Life" will play by default if available.</p>
    </div>
    <div id="top-bar">
        <input type="range" id="songPositionSlider" min="0" max="100" value="0" step="0.01">
    </div>
    <div id="ui-container">
        <div class="control-group">
            <label id="uploadLabel" for="midiFileInput">Upload Different MIDI</label>
            <input type="file" id="midiFileInput" accept=".mid,.midi">
        </div>
        <div class="control-group">
            <label for="showLabelsCheckbox">Show Note Labels</label>
            <input type="checkbox" id="showLabelsCheckbox">
        </div>
        <div class="control-group">
            <label for="volumeSlider">Volume</label>
            <input type="range" id="volumeSlider" min="0" max="1" value="0.3" step="0.01">
        </div>
    </div>
    <canvas id="pianoCanvas"></canvas>

<script>
    // --- Element Refs ---
    const canvas = document.getElementById('pianoCanvas');
    const ctx = canvas.getContext('2d');
    const showLabelsCheckbox = document.getElementById('showLabelsCheckbox');
    const volumeSlider = document.getElementById('volumeSlider');
    const startOverlay = document.getElementById('start-overlay');
    const midiFileInput = document.getElementById('midiFileInput');
    const songPositionSlider = document.getElementById('songPositionSlider');

    // --- State ---
    let audioContext, masterGain;
    let song = null;
    let isPlaying = false;
    let animationFrameId = null;
    let songStartTime = 0;
    let nextNoteIndex = 0;

    // --- Audio Engine ---
    function setupAudio() {
        if (audioContext) return;
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioContext.createGain();
        masterGain.connect(audioContext.destination);
        masterGain.gain.setValueAtTime(volumeSlider.value, audioContext.currentTime);
        volumeSlider.addEventListener('input', (e) => {
            if (masterGain) masterGain.gain.setValueAtTime(parseFloat(e.target.value), audioContext.currentTime);
        });
    }

    function playNoteSound(midi, velocity, time) {
        if (!audioContext) return;
        const freq = 440 * Math.pow(2, (midi - 69) / 12);
        const osc = audioContext.createOscillator();
        const noteGain = audioContext.createGain();
        osc.connect(noteGain);
        noteGain.connect(masterGain);
        osc.type = 'triangle';
        osc.frequency.value = freq;
        const volume = (velocity / 127) * parseFloat(volumeSlider.value);
        noteGain.gain.setValueAtTime(volume, time);
        noteGain.gain.exponentialRampToValueAtTime(0.0001, time + 0.8);
        osc.start(time);
        osc.stop(time + 0.8);
    }
    
    // --- MIDI Parsing Engine ---
    function midiToSong(data) {
        const midiFile = new Uint8Array(data); let pos = 0;
        const readUint = (len) => { let v = 0; while (len-- > 0) v = (v << 8) | midiFile[pos++]; return v; };
        const readVarLen = () => { let v = 0; let n; do { n = readUint(1); v = (v << 7) | (n & 0x7F); } while (n & 0x80); return v; };
        readUint(4); readUint(4); readUint(2); const trackCount = readUint(2); const timeDivision = readUint(2);
        const notes = [];
        for (let i = 0; i < trackCount; i++) {
            readUint(4); let trackEnd = readUint(4) + pos; let currentTime = 0; let lastStatus = 0; let tempo = 120;
            while (pos < trackEnd) {
                currentTime += (readVarLen() / timeDivision) * (60 / tempo); let status = readUint(1);
                if ((status & 0x80) === 0) { status = lastStatus; pos--; } lastStatus = status;
                const type = status >> 4;
                if (type === 9) { const p = readUint(1), v = readUint(1); notes.push({ type: v > 0 ? 'on' : 'off', time: currentTime, pitch: p, velocity: v }); }
                else if (type === 8) notes.push({ type: 'off', time: currentTime, pitch: readUint(1) });
                else if (type === 15 && (status & 15) === 15) { const metaType = readUint(1), len = readVarLen(); if (metaType === 81) tempo = 60000000 / readUint(3); else pos += len; }
                else pos += { 10: 2, 11: 2, 12: 1, 13: 1, 14: 2 }[type] || 0;
            }
        }
        notes.sort((a, b) => a.time - b.time); const onNotes = {}; const finalNotes = [];
        notes.forEach(note => {
            if (note.type === 'on') onNotes[note.pitch] = note;
            else if (note.type === 'off' && onNotes[note.pitch]) {
                const onNote = onNotes[note.pitch];
                finalNotes.push({ time: onNote.time, duration: note.time - onNote.time, midi: onNote.pitch, velocity: onNote.velocity });
                delete onNotes[note.pitch];
            }
        });
        return finalNotes;
    }

    // --- Loading & Playback Control ---
    function stopSong() { if (animationFrameId) cancelAnimationFrame(animationFrameId); isPlaying = false; animationFrameId = null; }

    function loadSong(arrayBuffer) {
        stopSong(); song = midiToSong(arrayBuffer);
        const totalDuration = song.length > 0 ? song[song.length - 1].time + song[song.length - 1].duration : 0;
        songPositionSlider.max = totalDuration; songPositionSlider.style.display = 'block';
        startPlayback(0);
    }
    
    midiFileInput.addEventListener('change', (e) => { const file = e.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (ev) => loadSong(ev.target.result); reader.readAsArrayBuffer(file); } });
    
    async function loadDefaultSong() { try { const response = await fetch("Joe Hisaishi - Merry Go Round Of Life (Howl's Moving Castle).mid"); if (!response.ok) throw new Error("File not found"); loadSong(await response.arrayBuffer()); } catch (error) { console.warn("Default MIDI not found.", error); } }

    function startPlayback(seekTime) {
        if (!song || isPlaying) return; isPlaying = true; songStartTime = audioContext.currentTime - seekTime;
        nextNoteIndex = song.findIndex(note => note.time >= seekTime); if (nextNoteIndex === -1) nextNoteIndex = song.length;
        animate();
    }

    songPositionSlider.addEventListener('input', (e) => { if (song) { stopSong(); startPlayback(parseFloat(e.target.value)); } });
    
    // --- Keyboard & Drawing Setup ---
    const NOTE_FALL_DURATION = 2.0;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const keyMap = {};
    const keyData = []; // This array will hold all key data for drawing.
    const whiteKeyWidth = window.innerWidth / 52;
    const whiteKeyHeight = window.innerHeight * 0.25;
    const blackKeyWidth = whiteKeyWidth * 0.7;
    const blackKeyHeight = whiteKeyHeight * 0.6;
    let whiteKeyIndex = 0;

    for (let i = 0; i < 88; i++) {
        const midi = 21 + i;
        const isBlack = [1, 3, 6, 8, 10].includes(i % 12);
        const keyInfo = {
            isBlack,
            midi,
            x: isBlack ? (whiteKeyIndex * whiteKeyWidth) - (blackKeyWidth / 2) : whiteKeyIndex * whiteKeyWidth,
            width: isBlack ? blackKeyWidth : whiteKeyWidth,
            y: canvas.height - whiteKeyHeight,
            height: isBlack ? blackKeyHeight : whiteKeyHeight
        };
        keyMap[midi] = keyInfo;
        keyData.push(keyInfo);
        if (!isBlack) whiteKeyIndex++;
    }

    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const midiToNoteName = (midi) => noteNames[midi % 12];

    // --- Main Animation Loop ---
    function animate() {
        if (!isPlaying) return;
        const currentTime = audioContext.currentTime - songStartTime;
        if (currentTime > songPositionSlider.max) { stopSong(); return; }
        songPositionSlider.value = currentTime;

        // Schedule upcoming audio notes
        while (nextNoteIndex < song.length && song[nextNoteIndex].time < currentTime + 0.1) {
            const note = song[nextNoteIndex];
            playNoteSound(note.midi, note.velocity, songStartTime + note.time);
            nextNoteIndex++;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const keyboardTopY = canvas.height - whiteKeyHeight;

        // 1. Draw falling notes
        song.forEach(note => {
            const timeUntilHit = note.time - currentTime;
            if (timeUntilHit > -note.duration && timeUntilHit < NOTE_FALL_DURATION) {
                const key = keyMap[note.midi];
                const noteWidth = key.isBlack ? blackKeyWidth * 0.9 : whiteKeyWidth * 0.9;
                const xPos = key.x + (key.width - noteWidth) / 2;
                const yStart = keyboardTopY - (timeUntilHit / NOTE_FALL_DURATION) * keyboardTopY;
                const noteHeight = Math.max(1, (note.duration / NOTE_FALL_DURATION) * keyboardTopY);
                
                ctx.fillStyle = key.isBlack ? 'rgba(10, 150, 10, 1)' : 'rgba(50, 255, 50, 1)';
                ctx.beginPath();
                ctx.roundRect(xPos, yStart - noteHeight, noteWidth, noteHeight, 8);
                ctx.fill();

                if (showLabelsCheckbox.checked) {
                    ctx.fillStyle = '#FFF'; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center';
                    ctx.fillText(midiToNoteName(note.midi), xPos + noteWidth / 2, yStart - 5);
                }
            }
        });
        
        // 2. Draw the static piano keys (White keys first, then black)
        keyData.filter(k => !k.isBlack).forEach(key => {
            ctx.fillStyle = '#FFFFFF'; ctx.fillRect(key.x, key.y, key.width, key.height);
            ctx.strokeStyle = '#bbb'; ctx.strokeRect(key.x, key.y, key.width, key.height);
        });
        keyData.filter(k => k.isBlack).forEach(key => {
            ctx.fillStyle = '#222222'; ctx.fillRect(key.x, key.y, key.width, key.height);
        });
        
        // 3. Draw key highlights on top of the static keys
        song.forEach(note => {
            if (currentTime >= note.time && currentTime < note.time + note.duration) {
                const key = keyMap[note.midi];
                ctx.fillStyle = key.isBlack ? 'rgba(10, 120, 10, 1)' : 'rgba(10, 200, 10, 1)';
                ctx.fillRect(key.x, key.y, key.width, key.height);
            }
        });
        
        animationFrameId = requestAnimationFrame(animate);
    }
    
    startOverlay.addEventListener('click', async () => { await setupAudio(); startOverlay.style.display = 'none'; await loadDefaultSong(); }, { once: true });
</script>
</body>
</html>
